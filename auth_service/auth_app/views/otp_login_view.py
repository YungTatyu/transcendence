import logging

import jwt
from rest_framework import status
from rest_framework.exceptions import AuthenticationFailed
from rest_framework.response import Response
from rest_framework.views import APIView

from auth_app.serializers.login_serializer import (
    OTPLoginSerializer,
    OTPVerificationSerializer,
)

logger = logging.getLogger(__name__)


class OTPLoginView(APIView):
    """
    既存ユーザーのログイン処理
    """

    def post(self, request, *args, **kwargs):
        """
        1. ユーザー名とパスワードで認証
        2. 認証成功後、OTP 検証ステップへ進む
        """

        try:
            serializer = OTPLoginSerializer(data=request.data)
            serializer.is_valid(raise_exception=True)
        except AuthenticationFailed as e:
            logger.error(f"Authentication failed: {str(e)}")
            return Response(
                {"error": "Authentication failed."}, status=status.HTTP_401_UNAUTHORIZED
            )
        except Exception as e:
            logger.error(f"Error occurred: {str(e)}")
            return Response({"error": str(e)}, status=status.HTTP_400_BAD_REQUEST)

        user = serializer.validated_data["user"]
        response = Response(
            {
                "message": "Use the OTP generated by your authentication app to complete the login process."
            },
            status=status.HTTP_200_OK,
        )

        response.set_cookie(
            key="email",
            value=user.email,
            httponly=True,
            secure=True,
            path="/",
            max_age=300,
        )

        logger.info(f"OTP login initiated for user: {user.email}")
        return response


class OTPLoginVerificationView(APIView):
    """
    OTP の検証
    """

    def post(self, request, *args, **kwargs):
        serializer = OTPVerificationSerializer(data=request.data)
        if not serializer.is_valid():
            logger.warn("Invalid OTP request")
            return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)

        user = serializer.validated_data["user"]

        # TODO 署名を組み込んだJWTの生成
        tokens = {
            "access": jwt.encode({"user_id": user.user_id}, None, algorithm=None),
            # refresh tokenの生成方法も要検討
            "refresh": jwt.encode({"user_id": user.user_id}, None, algorithm=None),
        }

        response = Response(
            {"message": "OTP verification successful.", "userId": user.user_id},
            status=status.HTTP_200_OK,
        )

        # JWT を HttpOnly Cookie に保存
        response.set_cookie(
            key="access_token",
            value=tokens["access"],
            httponly=True,  # JavaScript からアクセス不可 (XSS 対策)
            secure=True,  # HTTPS のみで送信 (本番環境では必須) TODO revert True
            samesite="None",  # CSRF 対策 (Lax か Strict)
            path="/",
            domain=".transcen.com",  # 親ドメインを設定
        )
        response.set_cookie(
            key="refresh_token",
            value=tokens["refresh"],
            httponly=True,
            secure=True,  # HTTPS のみで送信 (本番環境では必須) TODO revert True
            samesite="None",  # CSRF 対策 (Lax か Strict)
            path="/",
            domain=".transcen.com",  # 親ドメインを設定
        )

        response.delete_cookie("email", path="/")

        logger.info(f"OTP verified successfully for user: {user.email}")
        return response
